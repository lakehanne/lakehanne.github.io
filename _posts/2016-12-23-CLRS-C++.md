---
layout: post
date: 2017-01-07 12:25:00
title: "<center>Passing the google interview</center>"
excerpt: "<center>C++/Python Implementation of Common Algorithms and Data Structures Problems
        </center></i>"
permalink: CLRS-C++
comments: true
mathjax: true
---

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>

<!--Mathjax Parser -->
<script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>

### [Table of Contents](#table-of-contents):

  - [Introduction](#introduction)
  - [Warm-up Questions](#warm-up-questions)    
    - [Array decays to a pointer](#array-decays-to-a-pointer)    
    - [Atoi Implementation](#atoi-implementation)
    - [Reversing a string](#reverse-a-string)
    - [Const Iterator on a vector dynamic set](#const-iterator)
    - [Unordered Map](#unordered-map)
    - [Matrix Multiply](#matrix-multiply)
  - [Sorting](#sorting)
    - [Insert-Sort (2.1-1)](#insert-sort)
    - [Insert-Sort in Descending Order (2.1-2)](#insert-sort-in-descending-order)
    - [LineSearch (2.1-3)](#lineSearch)
    - [Merge-Sort (2.3-1)](#merge-sort)
    - [HeapSort](#heapsort)
    - [QuickSort](#quicksort)
    - [Randomized-QuickSort](#randomized-quicksort)
  - [Data Structures](#data-structures)

<a name='introduction'></a>
## `Introduction`

Most of these solutions are C++ solutions to some of the algorithm problems in the Introduction to Algorithms book by Cormen et. al. There are some other solutions to commonly-asked Google interview questions. I wrote most of these implementations while preparing for my first google phone screening interview in December of 2016. Zhenchao Gan has some pseudocode solutions to similar problems on his [github page](https://github.com/gzc/CLRS).

You would not get questions that directly ask you to implement most of these algorithms but knowing these algorithms and how to implement them in code would help you in faster answering your questions.

These solutions have been tested using `g++ 4.8.4` with c++ 11/14 support on Ubuntu 14.04. The solutions are being developed over time. You may find a longer post on this page when you check it at a a later time.

<a name='warm-up-questions'></a>
## `Warm-up Questions`

Usually in a google interview, there will be a first soft-ball question which you are expected to finish in a reasonable time before a **hardcore** question that will test your understanding of data structures. I gleaned these soft-ball questions from the internet and decided to answer common warm-ups in this section. The first question is usually for the interviewer to figure out if you can actually write a code. You are being hired to write code. So be ready to prove it. If you do not pass this stage, you might get a complimentary ride back to your erstwhile work as most google interviewers would not see the point of continuing interviewing you. I've heard a lot of people flunk it at this stage. So it is worthwhile boning up on your coding skills.

<a name='array-decays-to-a-pointer'></a>
### `Array decays to a pointer`

In C/C++, know that the raw array `A[]` decays to a pointer.

[Code](/src/arraydecaystopointer.cxx)

<a name='atoi-implementation'></a>
### `Atoi Implementation`

Atoi converts the pointee in the pointer `char* argv` or pointees in the pointer to an array 
`char *argv[]/char **argv` to an integer. This code should be easily adaptable for `atoll` and its other variants

[Code](https://github.com/lakehanne/CLRS/blob/master/src/atoi.cxx)

<a name='reverse-a-string'></a>
### `Reverse a String`

This is a fairly common interview question. 

[C Code](https://github.com/lakehanne/CLRS/blob/master/src/reverse.c)

<a name='const-iterator'></a>
### `Const Iterator on a vector dynamic set`

This is to test your understanding of dynamic set operations and how a pointer that reads from memory 
should not modify the data it is reading from. A similar question might be to implement a print function from a data structure (in this case, remember to add a const keyword in front of the print member function). 

[C++ 11 Code](https://github.com/lakehanne/CLRS/blob/master/src/vec.cxx)

<a name='unordered-map'></a>
### `Unordered Map`

Interviewers sometimes ask this to get a feel for your understanding of data structures.

[C++ 11 Code](https://github.com/lakehanne/CLRS/blob/master/src/unordered_map.cxx)

<a name='matrix-multiply'></a>
### `Multiplying-two-square-matrices`

This is also a fairly common question. The standard time-based multiplication requires \\(\theta(n^3)\\) time. If you are asked to optimize the code, [Strassen's algorithm](https://en.wikipedia.org/wiki/Strassen_algorithm) allows us to do the multiplication in \\(\theta(n^{\, lg 7})\\ \approx \theta^{2.8074}\\) time.

[Python Code](https://github.com/lakehanne/CLRS/blob/master/src/Matmuls/sqmatmaul.py)

<a name='sorting'></a>
## `Sorting`

Here, I illustrate with examples two \\(\theta(n \, lg \, n)\\) worst-case algorithms (i.e. mergesort and heapsort), and two  \\(\theta(n^2)\\) worst-case algorithms (i.e. insertion sort and quicksort). I also implement the randomized version of the quicksort algorithm in `Python`.

<a name='insert-sort'></a>
### `Insert-Sort (CLRS 2.1-1)`

Using Figure 2.2 as a model, illustrate the operation of `INSERTION-SORT` on the
array \\(A= (31, 41, 59, 26, 41, 58)\\).

This sorts in increasing order from left to right.

[C++ 11 Code](https://github.com/lakehanne/CLRS/blob/master/src/Sorting/insertsort.cxx)

<a name='insert-sort-in-descending-order'></a>
### `Insert-Sort in Descending Order (2.1-2)`

Rewrite the INSERTION-SORT procedure to sort into nonincreasing instead of non-decreasing order.

[C++ 11 Code](https://github.com/lakehanne/CLRS/blob/master/src/Sorting/insertsort_descending.cxx)

<a name='lineSearch'></a>
### `LineSearch (2.1-3)`

Consider the searching problem:

Input: A sequence of n numbers \\(A = (a\_1, a\_2, \ldots , a\_n) \\) and a value \\(\nu.\\)

Output: An index i such that \\(\nu = A[i] \\) or the special value NIL if \\(\nu\\) does not appear in \\(A\\).
Write pseudocode for _**linear search**_, which scans through the sequence, looking for \\(\nu\\). Using a loop invariant, prove that your algorithm is correct. Make sure that your loop invariant fulfills the three necessary properties.

Complexity: \\(O(n)\\) as you have to go though every element in the list in the worst case.

[C++ 11 Code](https://github.com/lakehanne/CLRS/blob/master/src/Sorting/linesearch.cxx)

<a name='merge-sort'></a>
### `Merge-Sort (2.3-1)`

Using Figure 2.4 as a model, illustrate the operation of merge sort on the array \\( A = (3, 41, 52, 26, 38, 57, 9, 49) \\).

Complexity: Worst case: \\(\theta(n \, lg \, n)\\) | Average Case: \\(\theta(n \, lg \, n)\\)

[C++ 11 Code](https://github.com/lakehanne/CLRS/blob/master/src/Sorting/mergesort.cxx)

[Python Code](https://github.com/lakehanne/CLRS/blob/master/src/Sorting/mergesort.py)

<a name='heapsort'></a>
### `HeapSort`

Complexity: Worst case: \\(O(n \, lg \, n)\\). The Max-Heapify algorithm is \\(O(lg \, n)\\) while the build-max heap algorithm takes \\(O(n)\\) time.

[C++ 11 Code](https://github.com/lakehanne/CLRS/blob/master/src/Sorting/heapsort.cxx)

[Python Code](https://github.com/lakehanne/CLRS/blob/master/src/Sorting/heapsort.py)

<a name='quicksort'></a>
### `QuickSort`

Complexity: Worst case: \\(\theta(n^2\\) | Average Case: \\(\theta(n^2\\) 

[Python Code](https://github.com/lakehanne/CLRS/blob/master/src/Sorting/quicksort.py)


<a name='randomized-quickSort'></a>
### `Randomized-QuickSort`

Complexity: Worst case: \\(\theta(n^2)\\) | Average Case: \\(\theta(n^2)\\) 

Here, the only difference from quicksort is that we randomize the choice of the end of our subarray.

[Python Code](https://github.com/lakehanne/CLRS/blob/master/src/Sorting/randomized_quicksort.py)

<a name='data-structures'></a>
## Data Structures

This is the meat of most big-tech company interviews and you should try your best to know what is going on **under the hood** in these algorithms. CLRS is a good reference. Covering the Part II section of the book is very important to understanding these algorithms. In this section, I provide implementations in C++  11 and python for `randomized binary trees`, `hash maps` and `lists`
